package it.denzosoft.jreverse.reporter.strategy;

import it.denzosoft.jreverse.core.exception.ReportGenerationException;
import it.denzosoft.jreverse.core.model.*;
import it.denzosoft.jreverse.core.port.ReportFormat;
import it.denzosoft.jreverse.core.port.ReportType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.EnumSource;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Set;

import static org.assertj.core.api.Assertions.*;

class HtmlReportStrategyTest {
    
    private HtmlReportStrategy strategy;
    private JarContent mockJarContent;
    
    @BeforeEach
    void setUp() throws Exception {
        strategy = new HtmlReportStrategy();
        
        // Create mock JAR content for testing
        Path tempJar = Files.createTempFile("test", ".jar");
        tempJar.toFile().deleteOnExit();
        
        JarLocation jarLocation = new JarLocation(tempJar);
        
        // Create mock class info
        ClassInfo classInfo = ClassInfo.builder()
            .fullyQualifiedName("com.example.TestClass")
            .classType(ClassType.CLASS)
            .build();
        
        mockJarContent = JarContent.builder()
            .location(jarLocation)
            .jarType(JarType.REGULAR_JAR)
            .classes(Set.of(classInfo))
            .build();
    }
    
    @Test
    void shouldHaveCorrectStrategyConfiguration() {
        assertThat(strategy.getStrategyName()).isEqualTo("HTML Report Generator");
        assertThat(strategy.getPriority()).isEqualTo(10);
        
        assertThat(strategy.getSupportedFormats())
            .containsExactly(ReportFormat.HTML);
            
        assertThat(strategy.getSupportedReportTypes())
            .contains(
                ReportType.PACKAGE_CLASS_MAP,
                ReportType.UML_CLASS_DIAGRAM,
                ReportType.PACKAGE_DEPENDENCIES,
                ReportType.MODULE_DEPENDENCIES
            );
    }
    
    @Test
    void shouldSupportHtmlFormatForSupportedReportTypes() {
        assertThat(strategy.supports(ReportType.PACKAGE_CLASS_MAP, ReportFormat.HTML)).isTrue();
        assertThat(strategy.supports(ReportType.UML_CLASS_DIAGRAM, ReportFormat.HTML)).isTrue();
        assertThat(strategy.supports(ReportType.PACKAGE_DEPENDENCIES, ReportFormat.HTML)).isTrue();
        assertThat(strategy.supports(ReportType.MODULE_DEPENDENCIES, ReportFormat.HTML)).isTrue();
    }
    
    @Test
    void shouldNotSupportNonHtmlFormats() {
        assertThat(strategy.supports(ReportType.PACKAGE_CLASS_MAP, ReportFormat.JSON)).isFalse();
        assertThat(strategy.supports(ReportType.PACKAGE_CLASS_MAP, ReportFormat.XML)).isFalse();
        assertThat(strategy.supports(ReportType.PACKAGE_CLASS_MAP, ReportFormat.CSV)).isFalse();
    }
    
    @Test
    void shouldNotSupportUnsupportedReportTypes() {
        // Test with a report type not in the supported list
        assertThat(strategy.supports(ReportType.SPRING_SECURITY_CONFIG, ReportFormat.HTML)).isFalse();
        assertThat(strategy.supports(ReportType.ENTITY_RELATIONSHIPS, ReportFormat.HTML)).isFalse();
    }
    
    @ParameterizedTest
    @EnumSource(value = ReportType.class, names = {
        "PACKAGE_CLASS_MAP", "UML_CLASS_DIAGRAM", "PACKAGE_DEPENDENCIES", "MODULE_DEPENDENCIES"
    })
    void shouldGenerateValidHtmlForSupportedReportTypes(ReportType reportType) throws Exception {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        
        strategy.generateReport(mockJarContent, reportType, ReportFormat.HTML, output);
        
        String html = output.toString("UTF-8");
        
        // Verify basic HTML structure
        assertThat(html).contains("<!DOCTYPE html>");
        assertThat(html).contains("<html lang=\"en\">");
        assertThat(html).contains("<head>");
        assertThat(html).contains("<body>");
        assertThat(html).contains("</html>");
        
        // Verify report-specific content
        assertThat(html).contains(reportType.getDisplayName());
        assertThat(html).contains("JReverse Analysis Report");
        assertThat(html).contains(mockJarContent.getLocation().getFileName());
        
        // Verify CSS is embedded
        assertThat(html).contains("<style>");
        assertThat(html).contains("font-family:");
        
        // Verify footer
        assertThat(html).contains("Generated by JReverse");
    }
    
    @Test
    void shouldGenerateArchitectureOverviewReport() throws Exception {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        
        strategy.generateReport(mockJarContent, ReportType.PACKAGE_CLASS_MAP, 
                               ReportFormat.HTML, output);
        
        String html = output.toString("UTF-8");
        
        assertThat(html).contains("Architecture Overview");
        assertThat(html).contains("Total Classes");
        assertThat(html).contains("JAR Type");
        assertThat(html).contains("1"); // Number of classes
        assertThat(html).contains("Regular JAR");
    }
    
    @Test
    void shouldGenerateClassSummaryReport() throws Exception {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        
        strategy.generateReport(mockJarContent, ReportType.UML_CLASS_DIAGRAM, 
                               ReportFormat.HTML, output);
        
        String html = output.toString("UTF-8");
        
        assertThat(html).contains("Class Summary");
        assertThat(html).contains("com.example.TestClass");
        assertThat(html).contains("Type: CLASS");
        assertThat(html).contains("Methods:");
        assertThat(html).contains("Fields:");
    }
    
    @Test
    void shouldGenerateDependencyAnalysisReport() throws Exception {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        
        strategy.generateReport(mockJarContent, ReportType.PACKAGE_DEPENDENCIES, 
                               ReportFormat.HTML, output);
        
        String html = output.toString("UTF-8");
        
        assertThat(html).contains("Dependency Analysis");
        assertThat(html).contains("Analyzing dependencies");
    }
    
    @Test
    void shouldGeneratePackageStructureReport() throws Exception {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        
        strategy.generateReport(mockJarContent, ReportType.MODULE_DEPENDENCIES, 
                               ReportFormat.HTML, output);
        
        String html = output.toString("UTF-8");
        
        assertThat(html).contains("Package Structure");
        assertThat(html).contains("Package analysis");
    }
    
    @Test
    void shouldThrowExceptionForUnsupportedCombination() {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        
        assertThatThrownBy(() -> 
            strategy.generateReport(mockJarContent, ReportType.SPRING_SECURITY_CONFIG, 
                                   ReportFormat.HTML, output))
            .isInstanceOf(ReportGenerationException.class)
            .hasMessageContaining("Unsupported combination");
    }
    
    @Test
    void shouldThrowExceptionForNullParameters() {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        
        assertThatThrownBy(() -> 
            strategy.generateReport(null, ReportType.PACKAGE_CLASS_MAP, 
                                   ReportFormat.HTML, output))
            .isInstanceOf(NullPointerException.class)
            .hasMessage("jarContent cannot be null");
            
        assertThatThrownBy(() -> 
            strategy.generateReport(mockJarContent, null, 
                                   ReportFormat.HTML, output))
            .isInstanceOf(NullPointerException.class)
            .hasMessage("reportType cannot be null");
            
        assertThatThrownBy(() -> 
            strategy.generateReport(mockJarContent, ReportType.PACKAGE_CLASS_MAP, 
                                   null, output))
            .isInstanceOf(NullPointerException.class)
            .hasMessage("format cannot be null");
            
        assertThatThrownBy(() -> 
            strategy.generateReport(mockJarContent, ReportType.PACKAGE_CLASS_MAP, 
                                   ReportFormat.HTML, null))
            .isInstanceOf(NullPointerException.class)
            .hasMessage("output cannot be null");
    }
    
    @Test
    void shouldHandleIoExceptionDuringGeneration() {
        // Create a mock output stream that throws IOException
        ByteArrayOutputStream faultyOutput = new ByteArrayOutputStream() {
            @Override
            public void write(byte[] b, int off, int len) {
                throw new RuntimeException(new IOException("Simulated IO error"));
            }
        };
        
        assertThatThrownBy(() -> 
            strategy.generateReport(mockJarContent, ReportType.PACKAGE_CLASS_MAP, 
                                   ReportFormat.HTML, faultyOutput))
            .isInstanceOf(RuntimeException.class)
            .hasCauseInstanceOf(IOException.class);
    }
    
    @Test
    void shouldGenerateResponsiveHtmlWithMobileSupport() throws Exception {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        
        strategy.generateReport(mockJarContent, ReportType.PACKAGE_CLASS_MAP, 
                               ReportFormat.HTML, output);
        
        String html = output.toString("UTF-8");
        
        // Verify responsive design elements
        assertThat(html).contains("viewport");
        assertThat(html).contains("@media");
        assertThat(html).contains("max-width: 768px");
    }
    
    @Test
    void shouldIncludeTimestampInGeneratedReport() throws Exception {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        
        strategy.generateReport(mockJarContent, ReportType.PACKAGE_CLASS_MAP, 
                               ReportFormat.HTML, output);
        
        String html = output.toString("UTF-8");
        
        // Verify timestamp is present (format: yyyy-MM-dd HH:mm:ss)
        assertThat(html).containsPattern("\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}");
    }
    
    @Test
    void shouldReturnImmutableArraysForSupportedTypesAndFormats() {
        ReportType[] types1 = strategy.getSupportedReportTypes();
        ReportType[] types2 = strategy.getSupportedReportTypes();
        ReportFormat[] formats1 = strategy.getSupportedFormats();
        ReportFormat[] formats2 = strategy.getSupportedFormats();
        
        // Arrays should be different instances (defensive copying)
        assertThat(types1).isNotSameAs(types2);
        assertThat(formats1).isNotSameAs(formats2);
        
        // But should contain the same elements
        assertThat(types1).containsExactly(types2);
        assertThat(formats1).containsExactly(formats2);
    }
}